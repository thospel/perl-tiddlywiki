#!/usr/bin/perl -w
use strict;
use warnings;
use feature qw(say);

# Make sure to do: apt install w3c-sgml-lib
our $VERSION = "1.000";

# If the program runs as /foobar/bin/program, find libraries in /foobar/lib
my $base;
BEGIN {
    # Even on windows FindBin uses / in the reported path
    use FindBin ();
    $FindBin::Bin =~
        ($^O eq "MSWin32" ?
         qr{^((?:[A-Z]:)?(?:/[a-zA-Z0-9_:.~ -]+)*)/[a-zA-Z0-9_.-]+/*\z} :
         qr{^((?:/[a-zA-Z0-9_:.-]+)*)/[a-zA-Z0-9_.-]+/*\z}) ||
         die "Could not parse bin directory '$FindBin::Bin'";
    # Use untainted version of lib
    require lib;
    $base = $1;
    "lib"->import(@ARGV && $ARGV[0] eq "--blib" ? shift && "$base/blib/lib" : "$base/lib");
}

print STDERR "Base=$base\n";
$ENV{PATH} = "/usr/bin:/bin";
delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

# use utf8;
use Carp;
use POSIX qw(strftime);
use Sys::Hostname;
use Fcntl qw(O_WRONLY O_CREAT O_TRUNC O_EXCL);
use Errno qw(ENOENT ESTALE);
use File::Spec;
use Getopt::Long 2.24 qw(:config bundling require_order);
# use XML::Simple qw(:strict);
#use XML::LibXML;
use XML::Parser;
use Data::Dumper;
local $Data::Dumper::Sortkeys = 1;
local $Data::Dumper::Indent = 1;

use constant {
    MODE	=> 2,
    WHERE	=> "/html/body/div/",
    INDEX	=> "index.html",
};

my $STORE = "storeArea";

defined(our $hostname = Sys::Hostname::hostname()) ||
    croak "Cannot determine hostname";
croak "Hostname looks like an ip address" if
    $hostname =~ m{^[0-9]+(?:\.[0-9]+)+\z};
# Just in case the domain got in there
$hostname =~ s/\..*//s;
$hostname =~ /^([a-zA-Z0-9_-]+)\z/ ||
    croak "Hostname '$hostname' looks too weird";
$hostname = lc $1;

# Import a complete file and return the contents as a single string
sub slurp {
    my $file = shift;
    my ($maybe_gone, $binmode);
    if (@_) {
        if (@_ == 1) {
            $maybe_gone = shift;
        } else {
            my %params = @_;
            $maybe_gone = delete $params{maybe_gone};
            $binmode	= delete $params{binmode};
            croak "Unknown parameter ", join(", ", map "'$_'", keys %params) if
                %params;
        }
    }
    croak "Filename is undefined" if !defined $file;
    croak "Filename '$file' contains \\x00" if $file =~ s/\x00/\\x00/g;
    open(my $fh, "<", $file) or
        $maybe_gone && ($! == ENOENT || $! == ESTALE) ?
	return undef : croak "Could not open '$file': $!";
    binmode($fh) if $binmode;
    my $rc = read($fh, my $slurp, -s $fh);
    croak "File '$file' is still growing" if $rc &&= read($fh, my $more, 1);
    croak "Error reading from '$file': $!" if !defined $rc;
    close($fh) || croak "Error while closing '$file': $!";
    return $slurp;
}

sub parent_dir {
    my ($volume, $directories) = File::Spec->splitpath(@_);
    return File::Spec->catpath($volume, $directories eq "" ? "." : $directories, "");
}

sub fsync {
    my ($path) = @_;

    if ($^O eq "MSWin32") {
        #open(my $fh, "<", $path) || croak "Could not open '$path': $!";
        #my $dh = Win32API::File::GetOsFHandle($fh) ||
        #    croak "Could not get Os handle for '$path'";
        #FlushFileBuffers($dh) || croak "Could not fsync '$path': $^E";
    } else {
        open(my $fh, "<", $path) || croak "Could not open '$path': $!";
        # Evil trick: Get write handle on read descriptor since perl only does
        # (f)sync on writable handles
        open(my $dh, ">&=", fileno($fh)) || croak "Could not fdopen: $!";
        $dh->sync || croak "Could not fsync '$path': $!";
    }
}

# Write remaining arguments to the file named in the first argument
# File is deleted on failure
# (When copying this code into test files you probably want to change the
#  default for fsync to 0 and depending on what is being tested maybe the
#  default for binmode to 1)
sub spew {
    my $file = shift;
    croak "filename is undefined" if !defined $file;
    defined || croak "undef value" for @_;

    my $fsync = 1;
    my $binmode;
    my $mode = 0666;
    my $exclusive = 0;
    my ($uid, $gid, $atomic);
    if (ref $_[0]) {
        ref $_[0] eq "HASH" || croak "Invalid spew parameters";
        my %params = %{+shift};

        $fsync     = delete $params{fsync} if exists $params{fsync};
        $binmode   = delete $params{binmode};
        $exclusive = delete $params{exclusive};
        $atomic	   = delete $params{atomic};
        if (exists $params{mode}) {
            $mode = delete $params{mode};
            if (defined $mode) {
                looks_like_number($mode) ||
                    croak "mode '$mode' doesn't look like a number";
                if ($mode =~ /^0[0-9]/) {
                    # Octal string
                    $mode =~ /^[0-7]+\z/ ||
                        croak "Mode '$mode' is not a valid octal number";
                    $mode = oct($mode);
                } else {
                    # undo it being a string
                    $mode = $mode+0;
                    $mode == int $mode ||
                        croak "mode '$mode' is not an integer";
                }
                croak sprintf("Invalid mode 0%03o", $mode) if $mode & ~0777;
            }
        }
        if (defined($uid = delete $params{uid})) {
            $uid =~ /^[0-9]+\z/ || croak "Uid '$uid' is not a natural number";
            $uid += 0;
            $mode = 0666 if !defined $mode;
        }
        if (defined($gid = delete $params{gid})) {
            $gid =~ /^[0-9]+\z/ || croak "Gid '$gid' is not a natural number";
            $gid += 0;
            $mode = 0666 if !defined $mode;
        }

        croak "Unknown parameter ", join(", ", map "'$_'", keys %params) if
            %params;
    }
    my $tmp = $atomic ? "$file.new.$hostname.$$" : $file;
    sysopen(my $fh, $tmp,
            O_WRONLY | O_CREAT | ($exclusive ? O_EXCL : O_TRUNC),
            defined $uid || defined $gid ? $mode & 0444 :
            defined $mode ? $mode : 0666) ||
                croak "Could not create '$tmp': $!";
    binmode $fh if $binmode;
    if (defined $uid || defined $gid) {
        $uid = -1 if !defined $uid;
        $gid = -1 if !defined $gid;
        eval {
            ## no critic (UselessNoCritic RequireCheckedSyscalls)
            chown($uid, $gid, $fh);
        } || do {
            croak "Could not chown $uid, $gid, '$tmp': $^E" if !$@;
            # Ok, this system doesn't support fchown
            # Try for plain chown, though it's racy if someone renames the
            # file in the mean time
            chown($uid, $gid, $tmp) ||
                croak "Could not chown $uid, $gid, '$tmp': $!";
            # Here we could check if the fstat looks ok now, but we run into
            # problems with system that don't actually HAVE sane mode bits
            # (I'm looking at you windows).
            # Just assume that we won the race
        };
    }
    # Mode must come after uid/gid
    if (defined $mode ) {
        my @stat = stat($fh) or
            croak "Assertion: Cannot fstat open file '$tmp': $!";
        $mode &= ~ umask();
        if (($stat[MODE] & 07777) != $mode) {
            # File has permissions different from what we want
            eval {
                ## no critic (UselessNoCritic RequireCheckedSyscalls)
                chmod($mode, $fh);
            } || do {
                croak "Could not chmod '$tmp': $!" if !$@;
                # Ok, this system doesn't support fchmod
                # Try for plain chmod, though it's racy if someone renames the
                # file in the mean time
                chmod($mode, $tmp) || croak "Could not chmod '$tmp': $!";
                # Here we could check if the fstat looks ok now, but we run into
                # problems with system that don't actually HAVE sane mode bits
                # (I'm looking at you windows).
                # Just assume that we won the race
            };
        }
    }
    eval {
        local ($\, $,);
        my $old_fh = select($fh);
        $| = 1;
        select($old_fh);
        print($fh @_)	|| croak "Error writing to '$tmp': $!";
        $^O eq "MSWin32" || $fh->sync || croak "Error syncing '$tmp': $!" if
            $fsync;
        close($fh)	|| croak "Error closing '$tmp': $!";
        !$atomic || rename($tmp, $file) ||
            croak "Could not rename '$tmp' to '$file': $!";
    };
    if ($@) {
        undef $fh;
        unlink($tmp) || die "Could not unlink '$tmp' after $@";
        die $@;
    }
    !$atomic || !$fsync || eval { fsync(parent_dir($file)) } || warn $@;
    return;
}

sub handle {
    my ($out, $state, $start, $parser, $elt, %attr) = @_;

    $elt eq "div" || return;
    my @context = $parser->context;
    @context >= 2 && @context <= 3 && $context[1] eq "body" && $context[0] eq "html" || return;
    if (@context == 3) {
        $context[2] eq "div" || return;
        my $id = $state->{div_key} // return;
        $id eq $STORE || return;
    }

    my $original_string = $parser->original_string;
    my $current_byte = $parser->current_byte - $state->{offset};
    my $len = length($original_string);
    my $end = $current_byte + $len;
    my $chunk = substr($state->{content}, 0, $end, "");
    $state->{offset} += $end;
    my $line = $parser->current_line;
    if (@context == 2) {
        if ($start) {
            my $id = $attr{id} // die "$elt: No id at line $line\n";
            !defined $state->{div_key} || die "Assertion: $elt: id '$id' while active '$state->{div_key}' at line $line";
            $state->{div_key} = $id;
            if ($out) {
                if ($id ne $STORE) {
                    substr($chunk, $current_byte, $len, "");
                }
            } else {
                $state->{divs}{$id} = $original_string;
            }
            $state->{template} .= $chunk;
        } else {
            my $id = $state->{div_key} //
                die "Assertion: $elt: end without id at line $line";
            $state->{div_key} = undef;
            if ($out) {
                if ($id eq $STORE) {
                    for my $title (sort keys %{$state->{store}}) {
                        my $chunk = $state->{store}{$title};
                        $chunk =~ s/\n\z// ||
                            die "Chunk title '$title' does not end in \\n";
                        $state->{template} .= "\n";
                        $state->{template} .= $chunk;
                    }
                } else {
                    $chunk = $state->{divs}{$id};
                    $chunk =~ s/\n\z// ||
                        die "Chunk '$id' does not end in \\n";
                }
                $state->{template} .= $chunk;
            } else {
                $state->{template} .= $id eq $STORE ? $chunk : $original_string;
                $state->{divs}{$id} .= $chunk;
                $state->{divs}{$id} .= "\n";
            }
        }
    } else {
        !$out || die "Parsing $STORE in out";
        # Due to the tests above we are in id $STORE
        if ($start) {
            my $title = $attr{title} // die "$elt: No title at line $line\n";
            !defined $state->{store_key} || die "Assertion: $elt: title '$title' while active '$state->{store_key}' at line $line";
            $state->{store_key} = $title;
            $chunk =~ s/^\n// ||
                die "$elt line $line does not have a preceding newline";
            $state->{store}{$title} = $chunk;
        } else {
            my $title = $state->{store_key} //
                die "Assertion: $elt: end without title at line $line";
            $state->{store_key} = undef;
            $state->{store}{$title} .= $chunk;
            $state->{store}{$title} .= "\n";
        }
    }
}

sub parse {
    my ($out, $state) = @_;

    $state->{offset} = 0;
    $state->{template}  = "";
    $state->{div_key}   = undef;
    $state->{store_key} = undef;

    my $p1 = XML::Parser->new(Handlers => {
        Start   => sub { handle($out, $state, 1, @_) },
        End	=> sub { handle($out, $state, 0, @_) },
    });
    my $content = $state->{content};
    $p1->parse($content);
    if ($out) {
        !defined $state->{divs}{$STORE} || die "Unexpected $STORE";
    } else {
        delete $state->{divs}{$STORE} || die "No $STORE";
    }
    !defined delete $state->{store_key} || die "store still active";
    !defined delete $state->{div_key} || die "div still active";
    $state->{template} .= delete $state->{content};
    delete $state->{offset};
    return delete $state->{template};
}

sub git {
    my $rc = system("git", @_);
    die "Unexpected exit code $rc from git @_" if $rc;
}

sub maybe_spew {
    my ($file, $content) = @_;
    die "Bad file '$file'" if $file =~ m{(?:^|/)\.};

    my $old = slurp($file, maybe_gone => 1);
    my $changed = 0;
    if (defined $old && $old eq $content) {
        # print STDERR "Not updating $file\n";
    } else {
        spew($file, { fsync => 0, atomic => 1 }, $content);
        $changed = 1;
    }
    return $changed;
}

sub output {
    my ($state, $template) = @_;

    my @files;
    my $dir = "../TiddlyWiki";
    chdir($dir) || die "Could not change to '$dir': $!";
    my $changes = 0;
    $changes += maybe_spew("template.html", $template);
    push @files, "template.html";
    for my $id (sort keys %{$state->{divs}}) {
        my $name = $id;
        $name =~ s{([/\\%])}{sprintf("%%%02X", ord $1)}eg;
        $changes += maybe_spew("$name.xml", $state->{divs}{$id});
        push @files, "$name.xml";
    }
    for my $title (sort keys %{$state->{store}}) {
        my $name = $title;
        $name =~ s{([/\\%])}{sprintf("%%%02X", ord $1)}eg;
        $changes += maybe_spew("$STORE/$name.xml", $state->{store}{$title});
        push @files, "$STORE/$name.xml";
    }
    # add does nothing if nothing changed
    git("add", "--", @files);
    my $text = strftime("TiddlyWiki updated by '$FindBin::Script' at %Y-%m-%d %T %z", localtime());
    git("commit", "-m", $text);
}

for my $file (@ARGV) {
    my $in = slurp($file);
    my $state = {
        content => $in,
        store => {},
        divs  => {},
    };
    my $template = parse(0, $state);
    # print Dumper($state);
    # print $template;
    $state->{content} = $template;
    my $out = parse(1, $state);
    $in eq $out || die "Incorrect regeneration";
    output($state, $template);
}
